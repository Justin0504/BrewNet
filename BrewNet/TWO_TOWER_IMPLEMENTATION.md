# Two-Tower æ¨èæ¨¡å‹è½åœ°ç­–ç•¥

## ğŸ“‹ ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [æ•°æ®å‡†å¤‡](#æ•°æ®å‡†å¤‡)
4. [æ¨¡å‹å®ç°](#æ¨¡å‹å®ç°)
5. [éƒ¨ç½²æ–¹æ¡ˆ](#éƒ¨ç½²æ–¹æ¡ˆ)
6. [è¯„ä¼°æŒ‡æ ‡](#è¯„ä¼°æŒ‡æ ‡)
7. [æ¸è¿›å¼å‡çº§](#æ¸è¿›å¼å‡çº§)

---

## ğŸ¯ æ¦‚è¿°

### Two-Tower ä¸ºä»€ä¹ˆé€‚åˆ BrewNet

**æ ¸å¿ƒä¼˜åŠ¿**ï¼š
- âœ… **å¬å› + ç²¾æ’åŒé˜¶æ®µ**ï¼šå…ˆå¬å›å¤§é‡å€™é€‰ï¼Œå†ç²¾ç»†æ’åº
- âœ… **åŒå‘åŒ¹é…å‹å¥½**ï¼šç”¨æˆ·å¡”å’Œç‰©å“å¡”åˆ†ç¦»å»ºæ¨¡
- âœ… **å†·å¯åŠ¨æ•ˆæœå¥½**ï¼šåªä¾èµ–ç‰¹å¾ï¼Œä¸éœ€è¦å†å²äº¤äº’
- âœ… **å¯æ‰©å±•æ€§å¼º**ï¼šä»ç®€å•åˆ°å¤æ‚ï¼Œå¹³æ»‘å‡çº§

### ä½ çš„æ•°æ®ä¼˜åŠ¿

**ä¸°å¯Œçš„ç»“æ„åŒ–ç‰¹å¾**ï¼š
- ç”¨æˆ·èµ„æ–™ï¼š6 å±‚ç»“æ„ï¼ˆCore, Professional, Intent, Preferences, Personality, Privacyï¼‰
- æŠ€èƒ½æ ‡ç­¾ï¼šæ˜ç¡®çš„æŠ€èƒ½ä½“ç³»
- æ„å›¾åˆ†ç±»ï¼š4 ç§ Networking Intention
- ç¤¾äº¤ä¿¡å·ï¼šVerified Status, Completion Rate

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç”¨æˆ·è¯·æ±‚                                â”‚
â”‚              "ç»™æˆ‘æ¨èåŒ¹é…çš„ç”¨æˆ·"                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  å¬å›é˜¶æ®µ (Recall)        â”‚
         â”‚  ç›®æ ‡: æ‰¾åˆ° 10,000 å€™é€‰   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                           â”‚
         â–¼                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·å¡”         â”‚        â”‚  ç‰©å“å¡”         â”‚
â”‚  (User Tower)   â”‚        â”‚  (Item Tower)   â”‚
â”‚                 â”‚        â”‚                 â”‚
â”‚ Input:          â”‚        â”‚ Input:          â”‚
â”‚ - Current User  â”‚        â”‚ - All Profiles  â”‚
â”‚   Features      â”‚        â”‚   Features      â”‚
â”‚                 â”‚        â”‚                 â”‚
â”‚ â†“               â”‚        â”‚ â†“               â”‚
â”‚ Embedding       â”‚        â”‚ Embedding       â”‚
â”‚ Layer           â”‚        â”‚ Layer           â”‚
â”‚ â†“               â”‚        â”‚ â†“               â”‚
â”‚ User Vector     â”‚        â”‚ Item Vectors    â”‚
â”‚ (64 dim)        â”‚        â”‚ (64 dim Ã— N)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                          â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Top-K æ£€ç´¢               â”‚
         â”‚  (ANN: Approximate NN)    â”‚
         â”‚  è¿”å› Top 1000            â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  ç²¾æ’é˜¶æ®µ (Ranking)       â”‚
         â”‚  ç›®æ ‡: é€‰å‡º Top 20        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  è¿”å›ç»™ç”¨æˆ·               â”‚
         â”‚  Top 20 æ¨èç»“æœ          â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç‰¹å¾å·¥ç¨‹

#### ç”¨æˆ·å¡”ç‰¹å¾å®šä¹‰

```swift
struct UserTowerFeatures {
    // ========== ç¨€ç–ç‰¹å¾ (Categorical) ==========
    
    // Core Identity
    let location: String                    // "San Francisco"
    let timeZone: String                    // "America/Los_Angeles"
    
    // Professional
    let industry: String                    // "Technology"
    let experienceLevel: String             // "senior"
    let careerStage: String                 // "manager"
    
    // Intention
    let mainIntention: String               // "learnGrow"
    
    // ========== å¤šå€¼ç¨€ç–ç‰¹å¾ (Multi-hot) ==========
    
    let skills: [String]                    // ["Swift", "AI", "Product Management"]
    let hobbies: [String]                   // ["Coffee Culture", "Photography"]
    let values: [String]                    // ["Innovative", "Collaborative"]
    let languages: [String]                 // ["English", "Mandarin"]
    let subIntentions: [String]             // ["careerDirection", "skillDevelopment"]
    
    // ========== å­¦ä¹ /æ•™æˆé…å¯¹ ==========
    
    let skillsToLearn: [String]             // æƒ³å­¦ä¹ çš„æŠ€èƒ½
    let skillsToTeach: [String]             // èƒ½æ•™æˆçš„æŠ€èƒ½
    let functionsToLearn: [String]          // æƒ³å­¦ä¹ çš„èŒèƒ½
    let functionsToTeach: [String]          // èƒ½æŒ‡å¯¼çš„èŒèƒ½
    
    // ========== æ•°å€¼ç‰¹å¾ (Dense) ==========
    
    let yearsOfExperience: Double           // 5.5 years
    let profileCompletion: Double           // 0.85
    let isVerified: Int                     // 1 or 0
    
    // ========== å†å²è¡Œä¸ºç‰¹å¾ (å¯é€‰) ==========
    
    let likedProfileIds: [String]           // ä¹‹å‰å–œæ¬¢è¿‡çš„ç”¨æˆ·ID
    let passedProfileIds: [String]          // ä¹‹å‰è·³è¿‡çš„ç”¨æˆ·ID
    let matchedProfileIds: [String]         // åŒ¹é…æˆåŠŸçš„ç”¨æˆ·ID
}
```

#### ç‰©å“å¡”ç‰¹å¾å®šä¹‰

```swift
struct ItemTowerFeatures {
    // ç»“æ„å®Œå…¨åŒ UserTowerFeatures
    // è¡¨ç¤º"å€™é€‰ç”¨æˆ·"çš„ç‰¹å¾
}
```

---

## ğŸ—‚ï¸ æ•°æ®å‡†å¤‡

### æ•°æ®åº“ Schema

```sql
-- 1. ç”¨æˆ·ç‰¹å¾è¡¨
CREATE TABLE user_features (
    user_id UUID PRIMARY KEY REFERENCES users(id),
    
    -- ç¨€ç–ç‰¹å¾
    location VARCHAR(100),
    time_zone VARCHAR(50),
    industry VARCHAR(100),
    experience_level VARCHAR(50),
    career_stage VARCHAR(50),
    main_intention VARCHAR(50),
    
    -- å¤šå€¼ç‰¹å¾ (JSONB)
    skills JSONB,                    -- ["Swift", "AI"]
    hobbies JSONB,                   -- ["Coffee", "Photo"]
    values JSONB,                    -- ["Innovative"]
    languages JSONB,                 -- ["English"]
    sub_intentions JSONB,            -- ["careerDirection"]
    
    -- å­¦ä¹ /æ•™æˆé…å¯¹
    skills_to_learn JSONB,           -- ["Machine Learning"]
    skills_to_teach JSONB,           -- ["iOS Development"]
    functions_to_learn JSONB,        -- ["Product Management"]
    functions_to_teach JSONB,        -- ["Software Engineering"]
    
    -- æ•°å€¼ç‰¹å¾
    years_of_experience FLOAT,
    profile_completion FLOAT,
    is_verified INT,
    
    -- Embedding å‘é‡ (æœªæ¥å­˜å‚¨)
    user_embedding FLOAT[],          -- [0.1, 0.2, ..., 0.9] 64ç»´
    
    -- å…ƒæ•°æ®
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 2. ç”¨æˆ·äº¤äº’æ—¥å¿—è¡¨
CREATE TABLE user_interactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    target_user_id UUID NOT NULL REFERENCES users(id),
    interaction_type VARCHAR(20) NOT NULL, -- 'like', 'pass', 'match'
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(user_id, target_user_id, interaction_type)
);

CREATE INDEX idx_interactions_user ON user_interactions(user_id);
CREATE INDEX idx_interactions_target ON user_interactions(target_user_id);
CREATE INDEX idx_interactions_type ON user_interactions(interaction_type);

-- 3. æ¨èç»“æœç¼“å­˜è¡¨
CREATE TABLE recommendation_cache (
    user_id UUID PRIMARY KEY REFERENCES users(id),
    recommended_user_ids JSONB,      -- ç”¨æˆ·IDåˆ—è¡¨
    scores JSONB,                    -- å¯¹åº”çš„åˆ†æ•°åˆ—è¡¨
    model_version VARCHAR(50),       -- "two_tower_v1"
    created_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP
);

CREATE INDEX idx_cache_expires ON recommendation_cache(expires_at);
```

### æ•°æ®åŒæ­¥è§¦å‘å™¨

```sql
-- å½“ç”¨æˆ·èµ„æ–™æ›´æ–°æ—¶ï¼Œè‡ªåŠ¨æ›´æ–° user_features
CREATE OR REPLACE FUNCTION sync_user_features()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO user_features (
        user_id,
        location,
        time_zone,
        industry,
        experience_level,
        career_stage,
        main_intention,
        skills,
        hobbies,
        values,
        languages,
        sub_intentions,
        skills_to_learn,
        skills_to_teach,
        functions_to_learn,
        functions_to_teach,
        years_of_experience,
        profile_completion,
        is_verified
    ) VALUES (
        NEW.id,
        NEW.core_identity->>'location',
        NEW.core_identity->>'time_zone',
        NEW.professional_background->>'industry',
        NEW.professional_background->>'experience_level',
        NEW.professional_background->>'career_stage',
        NEW.networking_intention->>'selected_intention',
        NEW.professional_background->'skills',
        NEW.personality_social->'hobbies',
        NEW.personality_social->'values_tags',
        NEW.professional_background->'languages_spoken',
        NEW.networking_intention->'selected_sub_intentions',
        -- æå– skills_to_learn (where learnIn = true)
        (SELECT jsonb_agg(e->>'skill_name')
         FROM jsonb_array_elements(NEW.networking_intention->'skill_development'->'skills') e
         WHERE (e->>'learn_in')::boolean = true),
        -- æå– skills_to_teach (where guideIn = true)
        (SELECT jsonb_agg(e->>'skill_name')
         FROM jsonb_array_elements(NEW.networking_intention->'skill_development'->'skills') e
         WHERE (e->>'guide_in')::boolean = true),
        -- æå– functions_to_learn/teach ç±»ä¼¼é€»è¾‘...
        COALESCE((NEW.professional_background->>'years_of_experience')::FLOAT, 0),
        -- è®¡ç®— profile_completion
        calculate_profile_completion(NEW),
        CASE WHEN NEW.privacy_trust->'verified_status' = 'verified_professional' THEN 1 ELSE 0 END
    )
    ON CONFLICT (user_id) DO UPDATE
    SET
        location = EXCLUDED.location,
        time_zone = EXCLUDED.time_zone,
        industry = EXCLUDED.industry,
        -- ... æ›´æ–°å…¶ä»–å­—æ®µ
        updated_at = NOW();
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_user_features
AFTER INSERT OR UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION sync_user_features();
```

---

## ğŸ’» æ¨¡å‹å®ç°

### é˜¶æ®µ 1: ç®€å•å‘é‡åŒ–ï¼ˆç«‹å³å¯ç”¨ï¼‰

**ä¸ä½¿ç”¨æ·±åº¦å­¦ä¹ ï¼Œå¿«é€Ÿä¸Šçº¿**

```swift
// MARK: - Simple Two-Tower Encoder
class SimpleTwoTowerEncoder {
    
    // ç‰¹å¾åº“ï¼ˆä»æ•°æ®ä¸­æ”¶é›†ï¼‰
    static let allSkills = [
        "Swift", "Python", "JavaScript", "React", "iOS Development",
        "AI", "Machine Learning", "Product Management", "UX Design",
        // ... æ›´å¤šæŠ€èƒ½
    ]
    
    static let allHobbies = [
        "Coffee Culture", "Photography", "Hiking", "Reading",
        "Gaming", "Music", "Travel", "Cooking",
        // ... æ›´å¤šçˆ±å¥½
    ]
    
    static let allIndustries = [
        "Technology", "Finance", "Healthcare", "Education",
        "E-commerce", "Gaming", "Media", "Consulting",
        // ... æ›´å¤šè¡Œä¸š
    ]
    
    // MARK: - ç¼–ç ç”¨æˆ·ä¸ºç‰¹å¾å‘é‡
    
    /// ç¼–ç  UserTower è¾“å…¥
    static func encodeUser(_ features: UserTowerFeatures) -> [Double] {
        var vector: [Double] = []
        
        // 1. One-hot ç¼–ç ç¨€ç–ç‰¹å¾
        vector += oneHotEncode(features.industry, allCategories: allIndustries)
        vector += oneHotEncode(features.experienceLevel, allCategories: ["entry", "mid", "senior"])
        vector += oneHotEncode(features.mainIntention, allCategories: ["learnGrow", "connectShare", "buildCollaborate", "unwindChat"])
        
        // 2. Multi-hot ç¼–ç å¤šå€¼ç‰¹å¾
        vector += multiHotEncode(features.skills, allCategories: allSkills)
        vector += multiHotEncode(features.hobbies, allCategories: allHobbies)
        vector += multiHotEncode(features.values, allCategories: ["Innovative", "Collaborative", "Curious", "Passionate"])
        
        // 3. å½’ä¸€åŒ–æ•°å€¼ç‰¹å¾
        vector.append(features.yearsOfExperience / 50.0)  // å½’ä¸€åŒ–åˆ° [0, 1]
        vector.append(features.profileCompletion)         // å·²ç»æ˜¯ [0, 1]
        vector.append(Double(features.isVerified))
        
        return vector
    }
    
    /// è®¡ç®—ç”¨æˆ· Embeddingï¼ˆç®€å•ç‰ˆï¼šæŠ•å½±åˆ°ä½ç»´ï¼‰
    static func computeEmbedding(_ features: [Double]) -> [Double] {
        // é™ç»´ï¼šä»é«˜ç»´ç‰¹å¾å‘é‡æŠ•å½±åˆ° 64 ç»´
        let embeddingDim = 64
        var embedding = [Double](repeating: 0.0, count: embeddingDim)
        
        // ç®€å•çš„çº¿æ€§æŠ•å½±ï¼ˆæœªæ¥å¯ä»¥ç”¨å­¦ä¹ åˆ°çš„æƒé‡ï¼‰
        for i in 0..<features.count {
            let hash = i % embeddingDim
            embedding[hash] += features[i]
        }
        
        // L2 å½’ä¸€åŒ–
        let norm = sqrt(embedding.map { $0 * $0 }.reduce(0, +))
        return embedding.map { $0 / max(norm, 1e-10) }
    }
    
    // MARK: - è®¡ç®—ç›¸ä¼¼åº¦
    
    /// è®¡ç®—ä¸¤ä¸ªç”¨æˆ·çš„åŒ¹é…åˆ†æ•°
    static func calculateSimilarity(
        userFeatures: UserTowerFeatures,
        candidateFeatures: ItemTowerFeatures
    ) -> Double {
        let userEmbedding = computeEmbedding(encodeUser(userFeatures))
        let candidateEmbedding = computeEmbedding(encodeCandidate(candidateFeatures))
        return cosineSimilarity(userEmbedding, candidateEmbedding)
    }
    
    // MARK: - Helper Functions
    
    private static func oneHotEncode(_ value: String, allCategories: [String]) -> [Double] {
        guard let index = allCategories.firstIndex(of: value) else {
            return [Double](repeating: 0.0, count: allCategories.count)
        }
        var oneHot = [Double](repeating: 0.0, count: allCategories.count)
        oneHot[index] = 1.0
        return oneHot
    }
    
    private static func multiHotEncode(_ values: [String], allCategories: [String]) -> [Double] {
        var multiHot = [Double](repeating: 0.0, count: allCategories.count)
        for value in values {
            if let index = allCategories.firstIndex(of: value) {
                multiHot[index] = 1.0
            }
        }
        return multiHot
    }
    
    private static func cosineSimilarity(_ a: [Double], _ b: [Double]) -> Double {
        let dotProduct = zip(a, b).map(*).reduce(0, +)
        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))
        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))
        return dotProduct / max(magnitudeA * magnitudeB, 1e-10)
    }
    
    /// ç¼–ç ç‰©å“å¡”è¾“å…¥ï¼ˆåŒç”¨æˆ·å¡”ï¼‰
    static func encodeCandidate(_ features: ItemTowerFeatures) -> [Double] {
        // è½¬æ¢ä¸º UserTowerFeatures æ ¼å¼
        let userFeatures = UserTowerFeatures(
            location: features.location,
            timeZone: features.timeZone,
            industry: features.industry,
            experienceLevel: features.experienceLevel,
            careerStage: features.careerStage,
            mainIntention: features.mainIntention,
            skills: features.skills,
            hobbies: features.hobbies,
            values: features.values,
            languages: features.languages,
            subIntentions: features.subIntentions,
            skillsToLearn: features.skillsToLearn,
            skillsToTeach: features.skillsToTeach,
            functionsToLearn: features.functionsToLearn,
            functionsToTeach: features.functionsToTeach,
            yearsOfExperience: features.yearsOfExperience,
            profileCompletion: features.profileCompletion,
            isVerified: features.isVerified,
            likedProfileIds: [],
            passedProfileIds: [],
            matchedProfileIds: []
        )
        return encodeUser(userFeatures)
    }
}
```

### é˜¶æ®µ 2: æ·±åº¦å­¦ä¹ æ¨¡å‹ï¼ˆPython è®­ç»ƒï¼‰

**ä½¿ç”¨ PyTorch è®­ç»ƒçœŸæ­£çš„ Two-Tower**

```python
# train_two_tower.py
import torch
import torch.nn as nn
import numpy as np
from torch.utils.data import Dataset, DataLoader
import json

class UserItemDataset(Dataset):
    """ç”¨æˆ·-ç‰©å“äº¤äº’æ•°æ®é›†"""
    def __init__(self, interactions_file):
        with open(interactions_file, 'r') as f:
            self.data = json.load(f)
    
    def __len__(self):
        return len(self.data)
    
    def __getitem__(self, idx):
        item = self.data[idx]
        return {
            'user_features': torch.FloatTensor(item['user_features']),
            'item_features': torch.FloatTensor(item['item_features']),
            'label': torch.FloatTensor([item['label']])  # 1=like, 0=pass
        }

class TwoTowerModel(nn.Module):
    """Two-Tower æ¨¡å‹"""
    
    def __init__(
        self,
        user_feature_dim: int,
        item_feature_dim: int,
        embedding_dim: int = 64
    ):
        super().__init__()
        
        # ç”¨æˆ·å¡”
        self.user_tower = nn.Sequential(
            nn.Linear(user_feature_dim, 128),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(64, embedding_dim)
        )
        
        # ç‰©å“å¡”
        self.item_tower = nn.Sequential(
            nn.Linear(item_feature_dim, 128),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(64, embedding_dim)
        )
        
        # L2 å½’ä¸€åŒ–å±‚
        self.normalize = nn.functional.normalize
    
    def forward(self, user_features, item_features):
        # åˆ†åˆ«é€šè¿‡ä¸¤ä¸ªå¡”
        user_emb = self.user_tower(user_features)
        item_emb = self.item_tower(item_features)
        
        # L2 å½’ä¸€åŒ–
        user_emb = self.normalize(user_emb, p=2, dim=1)
        item_emb = self.normalize(item_emb, p=2, dim=1)
        
        return user_emb, item_emb
    
    def predict_score(self, user_features, item_features):
        """é¢„æµ‹åŒ¹é…åˆ†æ•°"""
        user_emb, item_emb = self.forward(user_features, item_features)
        # ä½™å¼¦ç›¸ä¼¼åº¦ = ç‚¹ç§¯ï¼ˆå› ä¸ºå·²ç»å½’ä¸€åŒ–ï¼‰
        return (user_emb * item_emb).sum(dim=1)


def train_model():
    # åˆå§‹åŒ–
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = TwoTowerModel(
        user_feature_dim=512,  # æ ¹æ®ä½ çš„ç‰¹å¾ç»´åº¦è°ƒæ•´
        item_feature_dim=512,
        embedding_dim=64
    ).to(device)
    
    # ä¼˜åŒ–å™¨å’ŒæŸå¤±å‡½æ•°
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.BCEWithLogitsLoss()  # äºŒåˆ†ç±»æŸå¤±
    
    # æ•°æ®åŠ è½½
    dataset = UserItemDataset('interactions.json')
    dataloader = DataLoader(dataset, batch_size=64, shuffle=True)
    
    # è®­ç»ƒ
    for epoch in range(100):
        total_loss = 0
        for batch in dataloader:
            user_features = batch['user_features'].to(device)
            item_features = batch['item_features'].to(device)
            labels = batch['label'].to(device)
            
            # å‰å‘ä¼ æ’­
            user_emb, item_emb = model(user_features, item_features)
            
            # è®¡ç®—ç›¸ä¼¼åº¦
            scores = (user_emb * item_emb).sum(dim=1).unsqueeze(1)
            
            # æŸå¤±
            loss = criterion(scores, labels)
            
            # åå‘ä¼ æ’­
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            
            total_loss += loss.item()
        
        print(f'Epoch {epoch}, Loss: {total_loss / len(dataloader):.4f}')
    
    # ä¿å­˜æ¨¡å‹
    torch.save(model.state_dict(), 'two_tower_model.pth')
    print('Model saved!')

if __name__ == '__main__':
    train_model()
```

---

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### æ–¹æ¡ˆ A: iOS ç«¯é›†æˆï¼ˆCore MLï¼‰

```python
# è½¬æ¢ä¸º Core ML
import coremltools as ct

# åŠ è½½è®­ç»ƒå¥½çš„æ¨¡å‹
model = TwoTowerModel(user_feature_dim=512, item_feature_dim=512)
model.load_state_dict(torch.load('two_tower_model.pth'))
model.eval()

# è½¬æ¢ä¸º Core ML
example_input_user = torch.rand(1, 512)
example_input_item = torch.rand(1, 512)

traced_model = torch.jit.trace(
    model,
    (example_input_user, example_input_item)
)

coreml_model = ct.convert(
    traced_model,
    inputs=[
        ct.TensorType(name="user_features", shape=(1, 512)),
        ct.TensorType(name="item_features", shape=(1, 512))
    ],
    outputs=[
        ct.TensorType(name="user_embedding"),
        ct.TensorType(name="item_embedding")
    ]
)

coreml_model.save("TwoTower.mlmodel")
```

### æ–¹æ¡ˆ B: æœåŠ¡ç«¯éƒ¨ç½²ï¼ˆSupabase Edge Functionsï¼‰

```typescript
// supabase/functions/recommend/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  try {
    const { userId, limit = 20 } = await req.json()
    
    // 1. è·å–ç”¨æˆ·ç‰¹å¾
    const { data: userFeatures } = await supabase
      .from('user_features')
      .select('*')
      .eq('user_id', userId)
      .single()
    
    // 2. è®¡ç®—ç”¨æˆ· Embedding
    const userEmbedding = computeEmbedding(userFeatures)
    
    // 3. æ‰¹é‡è®¡ç®—æ‰€æœ‰å€™é€‰ç”¨æˆ·çš„ Embedding
    const { data: candidates } = await supabase
      .from('user_features')
      .select('*')
      .neq('user_id', userId)
      .limit(1000)
    
    // 4. è®¡ç®—ç›¸ä¼¼åº¦å¹¶æ’åº
    const scoredCandidates = candidates
      .map(candidate => {
        const candidateEmbedding = computeEmbedding(candidate)
        const score = cosineSimilarity(userEmbedding, candidateEmbedding)
        return { userId: candidate.user_id, score }
      })
      .sort((a, b) => b.score - a.score)
      .slice(0, limit)
    
    return new Response(
      JSON.stringify({ recommendations: scoredCandidates }),
      { headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 400
    })
  }
})

function cosineSimilarity(a: number[], b: number[]): number {
  const dot = a.reduce((sum, val, i) => sum + val * b[i], 0)
  const normA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0))
  const normB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0))
  return dot / (normA * normB)
}
```

---

## ğŸ“Š è¯„ä¼°æŒ‡æ ‡

### ç¦»çº¿è¯„ä¼°

```swift
struct ModelEvaluator {
    
    /// è®¡ç®— Hit Rate @ K
    static func hitRate(
        recommendations: [String],  // æ¨èçš„ç”¨æˆ·IDåˆ—è¡¨
        groundTruth: Set<String>    // ç”¨æˆ·å®é™…äº¤äº’çš„ç”¨æˆ·ID
    ) -> Double {
        let topK = Set(recommendations.prefix(K))
        let hits = topK.intersection(groundTruth)
        return Double(hits.count) / Double(K)
    }
    
    /// è®¡ç®— NDCG @ K
    static func ndcg(
        recommendations: [(userId: String, score: Double)],
        groundTruth: Set<String>
    ) -> Double {
        var dcg: Double = 0.0
        for (rank, rec) in recommendations.enumerated() {
            if groundTruth.contains(rec.userId) {
                dcg += 1.0 / log2(Double(rank + 2))
            }
        }
        
        // è®¡ç®— IDCG
        let idealHits = min(K, groundTruth.count)
        var idcg: Double = 0.0
        for i in 0..<idealHits {
            idcg += 1.0 / log2(Double(i + 2))
        }
        
        return dcg / max(idcg, 1e-10)
    }
    
    /// AUC (AUC-ROC)
    static func auc(
        positiveScores: [Double],
        negativeScores: [Double]
    ) -> Double {
        var auc: Double = 0.0
        for posScore in positiveScores {
            for negScore in negativeScores {
                if posScore > negScore {
                    auc += 1.0
                } else if posScore == negScore {
                    auc += 0.5
                }
            }
        }
        return auc / Double(positiveScores.count * negativeScores.count)
    }
}
```

### åœ¨çº¿ A/B æµ‹è¯•

```swift
// A/B æµ‹è¯•æ¡†æ¶
enum RecommendationVersion {
    case baseline      // å½“å‰æ—¶é—´æ’åº
    case twoTowerV1    // Two-Tower ç‰ˆæœ¬ 1
    case twoTowerV2    // Two-Tower ç‰ˆæœ¬ 2ï¼ˆå¢å¼ºï¼‰
}

class ABTestManager {
    
    func getRecommendationVersion(for userId: String) -> RecommendationVersion {
        // åŸºäºç”¨æˆ·IDå“ˆå¸Œåˆ†æ¡¶
        let bucket = hash(userId) % 100
        switch bucket {
        case 0..<50:
            return .baseline     // 50% ä½¿ç”¨åŸºçº¿
        case 50..<80:
            return .twoTowerV1   // 30% ä½¿ç”¨ Two-Tower V1
        default:
            return .twoTowerV2   // 20% ä½¿ç”¨ Two-Tower V2
        }
    }
    
    func trackMetric(
        version: RecommendationVersion,
        metric: String,
        value: Double
    ) {
        // å‘é€åˆ°åˆ†ææœåŠ¡ï¼ˆFirebase, Amplitude ç­‰ï¼‰
        Analytics.logEvent("recommendation_metric", parameters: [
            "version": version.rawValue,
            "metric": metric,
            "value": value
        ])
    }
}
```

---

## ğŸ”„ æ¸è¿›å¼å‡çº§

### Phase 1: åŸºç¡€è®¾æ–½ï¼ˆ1-2 å‘¨ï¼‰

**ç›®æ ‡**: å»ºç«‹æ•°æ®ç®¡é“

- [ ] åˆ›å»º `user_features` è¡¨
- [ ] å®ç°æ•°æ®åŒæ­¥è§¦å‘å™¨
- [ ] æ”¶é›†æ‰€æœ‰ç‰¹å¾ vocabularyï¼ˆskills, industries ç­‰ï¼‰
- [ ] å®ç°ç®€å•å‘é‡åŒ–

**äº¤ä»˜ç‰©**: æ•°æ®å¯ä»¥æ­£ç¡®åŒæ­¥ï¼Œç‰¹å¾æå–å®Œæ•´

---

### Phase 2: ç®€å• Two-Towerï¼ˆ2-3 å‘¨ï¼‰

**ç›®æ ‡**: éƒ¨ç½²åŸºäºè§„åˆ™çš„ Two-Tower

- [ ] å®ç° `SimpleTwoTowerEncoder`
- [ ] åœ¨ Supabase Edge Functions éƒ¨ç½²æ¨ç†
- [ ] æ›¿æ¢å½“å‰çš„æ—¶é—´æ’åº
- [ ] A/B æµ‹è¯•ï¼š50% baseline vs 50% Two-Tower

**é¢„æœŸæ•ˆæœ**: CTR æå‡ 20-30%

---

### Phase 3: æ·±åº¦å­¦ä¹  Two-Towerï¼ˆ1-2 æœˆï¼‰

**ç›®æ ‡**: è®­ç»ƒçœŸæ­£çš„ç¥ç»ç½‘ç»œ

- [ ] æ”¶é›† 1,000+ äº¤äº’æ•°æ®
- [ ] Python è®­ç»ƒè„šæœ¬
- [ ] æ¨¡å‹è½¬æ¢ Core ML
- [ ] iOS ç«¯é›†æˆ
- [ ] A/B æµ‹è¯•éªŒè¯

**é¢„æœŸæ•ˆæœ**: CTR æå‡ 40-60%

---

### Phase 4: æŒç»­ä¼˜åŒ–ï¼ˆé•¿æœŸï¼‰

**ç›®æ ‡**: æ¨¡å‹è¿­ä»£å’Œç²¾è°ƒ

- [ ] åœ¨çº¿å­¦ä¹ ï¼šæ ¹æ®æ–°äº¤äº’æ›´æ–°æ¨¡å‹
- [ ] è´Ÿé‡‡æ ·ä¼˜åŒ–ï¼šå¤„ç†ä¸å¹³è¡¡æ•°æ®
- [ ] å¤šä»»åŠ¡å­¦ä¹ ï¼šåŒæ—¶ä¼˜åŒ– match å’Œ response
- [ ] Feature Crossingï¼šå­¦ä¹ ç‰¹å¾ç»„åˆ

**é¢„æœŸæ•ˆæœ**: æŒç»­æå‡ 5-10%/å­£åº¦

---

## ğŸ¯ å…³é”®æˆåŠŸå› ç´ 

1. **æ•°æ®è´¨é‡**: ç‰¹å¾å‡†ç¡®ã€å®Œæ•´
2. **å†·å¯åŠ¨**: æ–°ç”¨æˆ·ä¹Ÿèƒ½è·å¾—å¥½æ¨è
3. **å¤šæ ·æ€§**: é¿å…è¿‡åº¦ç›¸ä¼¼çš„ç”¨æˆ·
4. **å®æ—¶æ€§**: æ¨èå»¶è¿Ÿ < 100ms
5. **å¯è§£é‡Šæ€§**: çŸ¥é“ä¸ºä»€ä¹ˆæ¨èè¿™ä¸ªç”¨æˆ·

---

## ğŸ“š å‚è€ƒèµ„æº

**å­¦æœ¯è®ºæ–‡**:
1. "Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations" (Google, 2019)
2. "Deep Neural Networks for YouTube Recommendations" (Google, 2016)

**å¼€æºå®ç°**:
1. PyTorch Two-Tower: https://github.com/facebookresearch/faiss
2. ANN Search: https://github.com/spotify/annoy
3. Core ML Tools: https://apple.github.io/coremltools/

**å•†ä¸šæ¡ˆä¾‹**:
1. Airbnb: "Applying Deep Learning to Airbnb Search"
2. Pinterest: "Home feed personalization at Pinterest"
3. LinkedIn: "Scaling Recommender Systems"

---

**å¼€å§‹ä½ çš„ Two-Tower ä¹‹æ—…å§ï¼ğŸš€**

